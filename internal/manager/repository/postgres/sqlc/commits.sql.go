// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: commits.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCommits = `-- name: CountCommits :one
SELECT COUNT(*)
FROM commits c
JOIN repositories r ON c.repository_id = r.id
JOIN authors a ON c.author_id = a.id
WHERE r.full_name = $1
    AND ($2::timestamptz IS NULL OR c.created_at >= $2)
    AND ($3::timestamptz IS NULL OR c.created_at <= $3)
    AND ($4::text IS NULL OR a.username = $4)
`

type CountCommitsParams struct {
	FullName string
	Column2  pgtype.Timestamptz
	Column3  pgtype.Timestamptz
	Column4  string
}

func (q *Queries) CountCommits(ctx context.Context, arg CountCommitsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCommits,
		arg.FullName,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findCommits = `-- name: FindCommits :many
SELECT 
    c.hash, c.message, c.url, c.created_at,
    a.id AS author_id, a.name AS author_name, a.email AS author_email, a.username AS author_username,
    r.id AS repo_id, r.watchers, r.stargazers, r.full_name AS repository, r.created_at AS repo_created_at, 
    r.updated_at AS repo_updated_at, r.language, r.forks
FROM commits c
JOIN repositories r ON c.repository_id = r.id
JOIN authors a ON c.author_id = a.id
WHERE r.full_name = $1
    AND ($2::timestamptz IS NULL OR c.created_at >= $2)
    AND ($3::timestamptz IS NULL OR c.created_at <= $3)
    AND ($4::text IS NULL OR a.username = $4)
ORDER BY c.created_at DESC
LIMIT $5 OFFSET $6
`

type FindCommitsParams struct {
	FullName string
	Column2  pgtype.Timestamptz
	Column3  pgtype.Timestamptz
	Column4  string
	Limit    int32
	Offset   int32
}

type FindCommitsRow struct {
	Hash           string
	Message        string
	Url            pgtype.Text
	CreatedAt      pgtype.Timestamptz
	AuthorID       int64
	AuthorName     string
	AuthorEmail    string
	AuthorUsername string
	RepoID         int64
	Watchers       int32
	Stargazers     int32
	Repository     string
	RepoCreatedAt  pgtype.Timestamptz
	RepoUpdatedAt  pgtype.Timestamptz
	Language       pgtype.Text
	Forks          int32
}

func (q *Queries) FindCommits(ctx context.Context, arg FindCommitsParams) ([]FindCommitsRow, error) {
	rows, err := q.db.Query(ctx, findCommits,
		arg.FullName,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommitsRow
	for rows.Next() {
		var i FindCommitsRow
		if err := rows.Scan(
			&i.Hash,
			&i.Message,
			&i.Url,
			&i.CreatedAt,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.AuthorUsername,
			&i.RepoID,
			&i.Watchers,
			&i.Stargazers,
			&i.Repository,
			&i.RepoCreatedAt,
			&i.RepoUpdatedAt,
			&i.Language,
			&i.Forks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthor = `-- name: GetAuthor :one
SELECT id, name, email, username FROM authors
WHERE id = $1
`

func (q *Queries) GetAuthor(ctx context.Context, id int64) (Author, error) {
	row := q.db.QueryRow(ctx, getAuthor, id)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Username,
	)
	return i, err
}

const getRepo = `-- name: GetRepo :one
SELECT id, watchers, stargazers, full_name, created_at, updated_at, language, forks FROM repositories
WHERE full_name = $1
`

func (q *Queries) GetRepo(ctx context.Context, fullName string) (Repository, error) {
	row := q.db.QueryRow(ctx, getRepo, fullName)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Watchers,
		&i.Stargazers,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Language,
		&i.Forks,
	)
	return i, err
}

const getTopCommitters = `-- name: GetTopCommitters :many
SELECT a.id, a.name, a.email, a.username, COUNT(c.hash) as commit_count
FROM authors a
JOIN commits c ON a.id = c.author_id
JOIN repositories r ON c.repository_id = r.id
WHERE r.full_name = $1
    AND ($2::timestamptz IS NULL OR c.created_at >= $2)
    AND ($3::timestamptz IS NULL OR c.created_at <= $3)
GROUP BY a.id, a.name, a.email, a.username
ORDER BY commit_count DESC
LIMIT $4 OFFSET $5
`

type GetTopCommittersParams struct {
	FullName string
	Column2  pgtype.Timestamptz
	Column3  pgtype.Timestamptz
	Limit    int32
	Offset   int32
}

type GetTopCommittersRow struct {
	ID          int64
	Name        string
	Email       string
	Username    string
	CommitCount int64
}

func (q *Queries) GetTopCommitters(ctx context.Context, arg GetTopCommittersParams) ([]GetTopCommittersRow, error) {
	rows, err := q.db.Query(ctx, getTopCommitters,
		arg.FullName,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCommittersRow
	for rows.Next() {
		var i GetTopCommittersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Username,
			&i.CommitCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAuthor = `-- name: SaveAuthor :one
INSERT INTO authors (id, name, email, username)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    email = EXCLUDED.email,
    username = EXCLUDED.username
RETURNING id, name, email, username
`

type SaveAuthorParams struct {
	ID       int64
	Name     string
	Email    string
	Username string
}

func (q *Queries) SaveAuthor(ctx context.Context, arg SaveAuthorParams) (Author, error) {
	row := q.db.QueryRow(ctx, saveAuthor,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Username,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Username,
	)
	return i, err
}

const saveCommit = `-- name: SaveCommit :exec
INSERT INTO commits (hash, author_id, message, url, created_at, repository_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (hash) DO NOTHING
`

type SaveCommitParams struct {
	Hash         string
	AuthorID     int64
	Message      string
	Url          pgtype.Text
	CreatedAt    pgtype.Timestamptz
	RepositoryID int64
}

func (q *Queries) SaveCommit(ctx context.Context, arg SaveCommitParams) error {
	_, err := q.db.Exec(ctx, saveCommit,
		arg.Hash,
		arg.AuthorID,
		arg.Message,
		arg.Url,
		arg.CreatedAt,
		arg.RepositoryID,
	)
	return err
}

const saveManyCommits = `-- name: SaveManyCommits :many
INSERT INTO commits (hash, author_id, message, url, created_at, repository_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (hash) DO NOTHING
RETURNING hash, author_id, message, url, created_at, repository_id
`

type SaveManyCommitsParams struct {
	Hash         string
	AuthorID     int64
	Message      string
	Url          pgtype.Text
	CreatedAt    pgtype.Timestamptz
	RepositoryID int64
}

func (q *Queries) SaveManyCommits(ctx context.Context, arg SaveManyCommitsParams) ([]Commit, error) {
	rows, err := q.db.Query(ctx, saveManyCommits,
		arg.Hash,
		arg.AuthorID,
		arg.Message,
		arg.Url,
		arg.CreatedAt,
		arg.RepositoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Commit
	for rows.Next() {
		var i Commit
		if err := rows.Scan(
			&i.Hash,
			&i.AuthorID,
			&i.Message,
			&i.Url,
			&i.CreatedAt,
			&i.RepositoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveRepo = `-- name: SaveRepo :exec
INSERT INTO repositories (id, watchers, stargazers, full_name, created_at, updated_at, language, forks)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (full_name) DO UPDATE SET
    watchers = EXCLUDED.watchers,
    stargazers = EXCLUDED.stargazers,
    updated_at = EXCLUDED.updated_at,
    language = EXCLUDED.language,
    forks = EXCLUDED.forks
`

type SaveRepoParams struct {
	ID         int64
	Watchers   int32
	Stargazers int32
	FullName   string
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	Language   pgtype.Text
	Forks      int32
}

func (q *Queries) SaveRepo(ctx context.Context, arg SaveRepoParams) error {
	_, err := q.db.Exec(ctx, saveRepo,
		arg.ID,
		arg.Watchers,
		arg.Stargazers,
		arg.FullName,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Language,
		arg.Forks,
	)
	return err
}
